---
title: "Simple CFR approach"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

 
require(knitr)
require(tidyverse)
require(gridExtra)
require(rstan)

source("R/DataLoadUtils.r")
source("R/BasicEpiAnalyses.r")

```


Here is the basic model. We are interested in estimating the CFR among confirmed 
cases, $\rho$. Presume that the time from confirmation to report of death (censoring at recovery) follows an exponential distribution:
$$\Pr(Y_i<t) = F(t; \lambda_1)$$
Where $Y_i$ is the time from confirmation to  death for person $i$.

Moreover, the time from confirmation to death or recovery (composite outcome) follows an exponential distribution:
$$\Pr(T_i<t) = G(t; \lambda)$$
Where $T_i$ is the time from confirmation to  death or recovery for person $i$.

To ease application of the above models to our dataset, which is organized by calendar date, we will assume both time to death and time to the composite outcome follow an exponential distirbution with a constant hazard function, $\lambda_1$ and $\lambda$, respectively, for now.

Let $d_{jv}$ be the number of reported deaths in location $j$ and calendar date $v$. Based on the 
above:
$$E(d_{jv}) = \sum_{k=0}^v n_{jk} \lambda_1$$
where $n_{jv}$ is the number in the risk set on that day (i.e., cumulative number of confirmed cases reported on day $v$ minus the cumulative number of deaths on that day and the cumulative number of people recovered). 

In addition, 
$$E(n_{jv}) = c_{jv} - \sum_{k=0}^{v-1} n_{jk}\lambda$$
where $n_{jv}$ is the number in the risk set on that day (i.e., cumulative number of confirmed cases reported on day $v$ minus the cumulative number of deaths on that day and the cumulative number of people recovered). 


Finally $$\rho = \int_0^\infty \hat{\lambda_1}[1 - \hat{G}(t)]dt = \int_0^\infty \hat{\lambda_1}e^{-\hat{\lambda}t}dt$$.

First, define the stan model.

```{stan, eval = FALSE, output.var="cfrmdl"}

data {
  int <lower=0> T; //the number of time steps included
  int <lower=0> L; //the number of locations we have data from
  
  real <lower=0> c[T,L]; // cumulative number of confirmed cases reported on each day. 
  real <lower=0> r[T,L]; // cumulative number of recovered cases reported on each day.
  int <lower=0> d[T,L]; // cumulative number of deaths reported on each day. 
  int <lower=0> n[T,L]; //number of currently infected people on each day. 
  int <lower = 0> V; // max infection duration (we should b e able to get rid of this)
}

parameters {
  real <lower=0> lambda1; //parameter for time to death distribution
  real <lower=0> lambda; // parameter for time to death or recovery distribution
  
}

transformed parameters {
  real <lower=0> expected_deaths[T,L]; // cumulative # deaths BY time T
  real <lower=0> expected_riskset[T,L]; // # infected at time T
  real <lower=0> expected_exit[T,L]; // cumulative # those who have exited due to death or recovery BY T

  
  //this can be made more efficient...but for now./
  for (j in 1:L) {
    for (t in 1:T) {
      expected_deaths[t,j] = 0.0001;
      expected_exit[t,j] = 0.0001;
        for (k in 1:t) {
        expected_exit[k,j] += n[k,j] * lambda;
        expected_deaths[k,j] += n[k,j] * lambda1;
        }
        expected_riskset[t,j] = c[t,j] - expected_exit[t,j];
        //expected_recovered[t,j] = (expected_exit[t,j] - expected_deaths[t,j]);

    }
  }
}

model {
 
  
  //definitely can be made more effcient.
  for (j in 1:L) {
    for (t in 1:T) {
      //target+=poisson_lpmf(d[t,j]|expected_deaths[t,j]) + poisson_lpmf(n[t,j]|expected_riskset[t,j]);
      target+=poisson_lpmf(d[t,j]|expected_deaths[t,j]) + poisson_lpmf(n[t,j]|expected_riskset[t,j]);
    }
  }
  // print(target());
}

//generated quantities {
//real  <lower = 0, upper = 1> rho;
// for (v in 1:V){
 //   rho += exp(loglambda1) * exp(-exp(loglambda) * v);
//    rho += lambda1 * exp(-lambda * v);
   
// }
//print(rho);
  //rho = integrate_1d(getft, 0, positive_infinity(), {lambda1, lambda}, t);

//} // The posterior predictive distribution"

```
Prep data and run model. 

```{r message=FALSE, warning=FALSE, include=FALSE}
library(readr)
library(tidyverse)
   #Load in the JHU CSSE Data
   jhucsse <- read_JHUCSSE_cases("2020-01-30 23:59", 
                                 append_wiki = TRUE)
  
  ##Continue to filter to China for the moment.
  ##also total the suspected and confirmed cases.
  jhucsse_china <- jhucsse %>% 
    filter(Country_Region%in%c("Mainland China", "Macau", "Hong Kong")) 
  
  jhucsse_china$Province_State <- as.factor(jhucsse_china$Province_State)
  
  
  incidence_data <- est_daily_incidence(jhucsse_china,
                                        ISOdate(2019,12,1),
                                        ISOdate(2020,1,30))
  
   #look at this before we do it.
  inc_plt <- incidence_data%>%filter(Date>"2020-1-1") %>% 
    ggplot(aes(x=Date,  y=Incidence, fill=Province_State)) +
    geom_bar(stat="identity", position="stack") +
    theme_bw()+theme(legend.position="bottom")
  

  inc_plt


  incidence_data<-
    incidence_data%>%filter(Date>"2020-1-1")
  
  #Add columns with indices for time and location
  incidence_data$loc <-
    as.numeric(incidence_data$Province_State)
  incidence_data$t <- as.numeric(as.Date(incidence_data$Date))-
    min(as.numeric(as.Date(incidence_data$Date))) + 1
  
  confirmed_data <- incidence_data
  confirmed_data$confirmeds <-ave(confirmed_data$Incidence, confirmed_data$loc, FUN=cumsum)
  
  # confirmed_data<-
  #   confirmed_data%>%filter(Date>"2020-1-1")
  # 
  # #Add columns with indices for time and location
  # confirmed_data$loc <-
  #   as.numeric(confirmed_data$Province_State)
  # confirmed_data$t <- as.numeric(as.Date(confirmed_data$Date))-
  #   min(as.numeric(as.Date(confirmed_data$Date))) + 1
  # 
  # 
  
  Tmax <- max(incidence_data$t)
  L <- max(incidence_data$loc)
  cases <- matrix(0,nrow=Tmax, ncol=L)
  
  for (i in 1:nrow(incidence_data)) {
    cases[incidence_data$t[i], incidence_data$loc[i]] <-
      incidence_data$Incidence[i]
  }
  
  confirmeds <- matrix(0,nrow=Tmax, ncol=L)
    for (i in 1:nrow(confirmed_data)) {
    confirmeds[confirmed_data$t[i], confirmed_data$loc[i]] <-
        confirmed_data$confirmeds[i]
  }

  recov_data <- est_daily_recovs(jhucsse_china,
                                        ISOdate(2019,12,1),
                                        ISOdate(2020,1,30))
   recov_data<-
    recov_data%>%filter(Date>"2020-1-1")
  
  #Add columns with indices for time and location
  recov_data$loc <-
    as.numeric(recov_data$Province_State)
  recov_data$t <- as.numeric(as.Date(recov_data$Date))-
    min(as.numeric(as.Date(recov_data$Date))) + 1
  
  recov_data$totrecovered <-ave(recov_data$Recovered, recov_data$loc, FUN=cumsum)
  
  recovered <- matrix(0,nrow=Tmax, ncol=L)
    for (i in 1:nrow(recov_data)) {
    recovered[recov_data$t[i], recov_data$loc[i]] <-
        recov_data$totrecovered[i]
  }
  
  
  
   death_data <- est_daily_deaths(jhucsse_china,
                                  ISOdate(2019,12,1),
                                  ISOdate(2020,1,30))
   
  #look at this before we do it.
  death_plt <- death_data%>%filter(Date>"2020-1-1") %>% 
    ggplot(aes(x=Date,   y=Deaths, fill=Province_State)) +
    geom_bar(stat="identity", position="stack") +
    theme_bw()+theme(legend.position="bottom")
  

  death_plt


  death_data<-
    death_data%>%filter(Date>"2020-1-1") %>% 
    drop_na(Deaths)
  
  
  #Add columns with indices for time and location
  death_data$loc <-
    as.numeric(as.numeric(death_data$Province_State))
  death_data$t <- as.numeric(as.Date(death_data$Date))-
    min(as.numeric(as.Date(incidence_data$Date))) + 1
  
  
  deaths <- matrix(0,nrow=Tmax, ncol=L)
  
  for (i in 1:nrow(death_data)) {
    deaths[death_data$t[i], death_data$loc[i]] <-
      death_data$Deaths[i]
  }
  
  deaths<- round(deaths)
  
  infected <- confirmeds - (deaths + recovered)
  infected[infected<0] <- 0
  infected <- round(infected)
  #recovered <- round(recovered)
  confirmeds[confirmeds == 0] <- 0.001
  
  ##we now have everything to run our stand model
  cfrmdl_data <- list(T=Tmax, L=L,
                      c = confirmeds,
                      d = deaths,
                      r = recovered, 
                      n = infected,
                      V = 100)

```

```{r eval=FALSE, echo = FALSE}
  cfrmdl_res <- sampling(cfrmdl, data=cfrmdl_data,
                         iter=10000, init=1)
  chains <- extract(cfrmdl_res)
  lambda1 <- chains$lambda1
  lambda <- chains$lambda
  outdat <- data.frame(lambda1 = lambda1, lambda = lambda)
  save(outdat, file = "data/outdat.RData")

```

Summarize

```{r, echo = FALSE }
load("data/outdat.RData")

lambda1 <- outdat[,1] #chains$lambda1
lambda <- outdat[,2] #chains$lambda

  
plot(density(lambda1), xlim=c(0,.1), type = "l")
lines(density(lambda))
plot(lambda, type = "l")
plot(lambda1, type = "l")



```

Results
```{r}

#move this into stan model later
rho <- matrix(nrow = length(lambda1))
for(i in 1:length(lambda1)){
  rho[i] <- integrate(function(x) {lambda1[i]*exp(-lambda[i]*x)}, lower = 0, upper = Inf)$value
}

median(rho)
quantile(rho, probs = c(.025, .975))

```

