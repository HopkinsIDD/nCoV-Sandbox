---
title: "Simple CFR approach"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

 
require(knitr)
require(tidyverse)
require(gridExtra)
require(rstan)


source("R/DataLoadUtils.r")
source("R/BasicEpiAnalyses.r")

```


Here is the basic model. We are interested in estimating the CFR among confirmed 
cases, $\rho$. Presume that the time from confirmation to report of death (censoring at recovery) follows an exponential distribution:
$$\Pr(Y_i<t) = F(t; \lambda_1)$$
Where $Y_i$ is the time from confirmation to  death for person $i$.

Moreover, the time from confirmation to death or recovery (composite outcome) follows an exponential distribution:
$$\Pr(T_i<t) = G(t; \lambda)$$
Where $T_i$ is the time from confirmation to  death or recovery for person $i$.

To ease application of the above models to our dataset, which is organized by calendar date, we will first assume both time to death and time to the composite outcome follow an exponential distirbution with a constant hazard function, $\lambda_1$ and $\lambda$, respectively, for now.

Let $d_{jv}$ be the number of reported deaths in location $j$ and calendar date $v$. Based on the 
above:
$$E(d_{jv}) = \sum_{k=0}^v n_{jk} \lambda_1$$
where $n_{jv}$ is the number in the risk set on that day (i.e., cumulative number of confirmed cases reported on day $v$ minus the cumulative number of deaths on that day and the cumulative number of people recovered). 

In addition, 
$$E(n_{jv}) = c_{jv} - \sum_{k=0}^{v-1} n_{jk}\lambda$$
where $n_{jv}$ is the number in the risk set on that day (i.e., cumulative number of confirmed cases reported on day $v$ minus the cumulative number of deaths on that day and the cumulative number of people recovered). 



Finally $$\rho = \int_0^\infty \hat{\lambda_1}[1 - \hat{G}(t)]dt = \int_0^\infty \hat{\lambda_1}e^{-\hat{\lambda}t}dt$$.

Now, let's assume the hazard of death and recovery is not constant over time. Assume time to death and time to the composite endpoint both follow Weibull distributions, such that $$\Pr(Y_i<t) = F(t; \lambda_1, \alpha_1) = 1 - \textrm{exp}(-(\lambda_1 t)^{\alpha_1})$$ and $$\Pr(T_i<t) = G(t; \lambda, \alpha)=1 - \textrm{exp}(-(\lambda t)^\alpha)$$

Let $d_{jv}$ be the number of reported deaths in location $j$ and calendar date $v$. Based on the 
above:
$$E(d_{jv}) = \sum_{k=0}^v \{n_{jk}  \sum_{h=1}^{max(T)} \alpha_1 \lambda_1 h^{\alpha_1 - 1}P(h|v)\}$$
where $n_{jv}$ is the number in the risk set on that day (i.e., cumulative number of confirmed cases reported on day $v$ minus the cumulative number of deaths on that day and the cumulative number of people recovered), $h$ indexes the unique values of time from symptom onset to death or recovery.

In addition, 
$$E(n_{jv}) = c_{jv} - \sum_{k=0}^{v-1} \{n_{jk}\sum_{h=1}^{max(T)} \alpha \lambda h^{\alpha - 1}P(h|v)\}\}$$
where $n_{jv}$ is the number in the risk set on that day (i.e., cumulative number of confirmed cases reported on day $v$ minus the cumulative number of deaths on that day and the cumulative number of people recovered). 

But unclear how to estimate $P(h|v)$.


Finally $$\rho = \int_0^\infty \hat{\lambda}_1\hat{\alpha}_1 t^{\hat{\alpha}_1-1}[1 - \hat{G}(t)]dt $$ 


 <!-- = \int_0^\infty \hat{\lambda}_1\hat{\alpha}_1 t^{\hat{\alpha}_1-1}e^{-(\hat{\lambda}t)^\hat{\alpha}}dt$$.  -->
First, define the stan model.


```{stan, eval = FALSE, output.var="cfrmdl_je"}

data {
  int <lower=0> T; //the number of time steps included
  int <lower=0> L; //the number of locations we have data from
  
  real <lower=0> c[T,L]; // cumulative number of confirmed cases reported on each day. 
  int <lower=0> d[T,L]; // cumulative number of deaths reported on each day. 
  int <lower=0> n[T,L]; //number of currently infected people on each day. 
  int <lower = 0> V; // max infection duration (we should b e able to get rid of this)
}

parameters {
  real <lower=0> lambda1; //parameter for time to death distribution
  real <lower=0> lambda; // parameter for time to death or recovery distribution
  
}

transformed parameters {
  real <lower=0> expected_deaths[T,L]; // cumulative # deaths BY time T
  real <lower=0> expected_exit[T,L]; // cumulative # those who have exited due to death or recovery BY T
  real <lower=0> expected_riskset[T,L]; // # infected at time T

  
  //this can be made more efficient...but for now./
  for (j in 1:L) {
    for (t in 1:T) {
      expected_exit[t,j] = 0.0001;
      expected_deaths[t,j] = 0.0001;
        for (k in 1:t) {
         expected_deaths[k,j] += n[k,j] * lambda1;
         expected_exit[k,j] += n[k,j] * lambda;
       }
       expected_riskset[t,j] = c[t,j] - expected_exit[t,j] + 0.0001;
        //expected_recovered[t,j] = (expected_exit[t,j] - expected_deaths[t,j]);

   }
  }
}

model {
 
  
  //definitely can be made more effcient.
  for (j in 1:L) {
    for (t in 1:T) {

      target+=poisson_lpmf(d[t,j]|expected_deaths[t,j]) + poisson_lpmf(n[t,j]|expected_riskset[t,j]);
    }
  }
  // print(target());
}



```

```{stan, eval = FALSE, output.var="cfrmdl2"}

data {
  int <lower=0> T; //the number of time steps included
  int <lower=0> L; //the number of locations we have data from
  int <lower=0> r[T,L]; //  number of recovered cases reported on each day.
  int <lower=0> d[T,L]; //  number of deaths reported on each day. 
  real <lower=0> c[T,L]; //number of new cases  on each day. 
  int w[L]; //is this wuhan
}

parameters {
  real <lower=0> lambda1; //parameter for time to death distribution
  real <lower=0> lambda; // parameter for time to death or recovery distribution
  real <lower= 0, upper=1> dr; // wuhan detect rate
}

transformed parameters {
  real <lower=0> expected_deaths[T,L]; //  # deaths at time T
  real <lower=0> expected_recovereds[T,L]; //  # those who have exited due to recovery at T
  real <lower=0> expected_riskset[T,L]; // expected people in risk set

for (j in 1:L) {
    expected_riskset[1,j] = c[1,j];
    expected_deaths[1,j] = expected_riskset[1,j] * lambda1 + 0.0001 ;
    expected_recovereds[1,j] = expected_riskset[1,j] * (lambda - lambda1) * (dr)^w[j] + 0.0001;
 
    for (t in 2:T) {
      expected_riskset[t,j] =  expected_riskset[t-1,j] + c[t,j] - 
                                expected_deaths[t-1,j] - expected_riskset[t-1,j] * (lambda - lambda1);
      expected_deaths[t,j] = expected_riskset[t,j] * lambda1 + 0.0001 ;
      expected_recovereds[t,j] = expected_riskset[t,j] * (lambda - lambda1) * (dr)^w[j] + 0.0001;
      
    }
  }
}


model {
  //definitely can be made more effcient.
  for (j in 1:L) {
    for (t in 1:T) {
      target+=poisson_lpmf(d[t,j]|expected_deaths[t,j]) + poisson_lpmf(r[t,j]|expected_recovereds[t,j]);
    }
  }
 
}


```
Time varying hazards
```{stan, eval = FALSE, output.var="cfrmdl3"}

data {
  int <lower=0> T; //the number of time steps included
  int <lower=0> L; //the number of locations we have data from
  int <lower = 0> V; // max infection duration (may not be needed)
  int <lower=0> r[T,L]; //  number of recovered cases reported on each day.
  int <lower=0> d[T,L]; //  number of deaths reported on each day. 
  real <lower=0> c[T,L]; //number of new cases  on each day. 
  int w[L]; //is this wuhan
}

parameters {
  real <lower=0> lambda1; //parameter for time to death distribution
  real <lower=0> lambda2; // parameter for time to death or recovery distribution
  real <lower=0> alpha1; //parameter for time to death distribution
  real <lower=0> alpha2; // parameter for time to death or recovery distribution
  real <lower= 0, upper=1> dr; // wuhan detect rate
}

transformed parameters {
  real <lower=0> expected_deaths[T,L]; //  # deaths at time T
  real <lower=0> expected_recovereds[T,L]; //  # those who have exited due to recovery at T
  //real <lower=0> expected_riskset[T,L]; // expected people in risk set
  real <lower=0> expected_riskset[L,T,V]; // expected people in risk set in inf dur timescale
  real <lower=0> h1[V];
  real <lower=0> h2[V];
  real <lower=0, upper=1> pk;


for (j in 1:L) {
    //expected_riskset[1,j] = c[1,j];
    //expected_deaths[1,j] = expected_riskset[1,j] * lambda1 + 0.0001 ;
    //expected_recovereds[1,j] = expected_riskset[1,j] * (lambda - lambda1) * (dr)^w[j] + 0.0001;
    
    expected_riskset[j,1,1] = c[1,j]+0.0001; //risk set on day 1 at inf duration 1 is just c1
    expected_deaths[1,j] = expected_riskset[j,1,1] * alpha1*lambda1*1^(alpha1-1) + 0.0001 ;
    expected_recovereds[1,j] = expected_riskset[j,1,1] * (alpha2*lambda2*1^(alpha2-1)) * (dr)^w[j] + 0.0001;
 
 
    for (t in 2:T) {
      expected_riskset[j,t,1] = c[t,j]+0.0001;
      expected_deaths[t,j] = expected_riskset[j,t,1] * alpha1*lambda1*1^(alpha1-1) + 0.0001 ;
      expected_recovereds[t,j] = expected_riskset[j,t,1] * (alpha2*lambda2*1^(alpha2-1)) * (dr)^w[j] + 0.0001;
      h1[1] = alpha1*lambda1*1^(alpha1-1);
      h2[1] = alpha2*lambda2*1^(alpha2-1);
      
      for(k in 2:t){
        h1[k] = alpha1*lambda1*k^(alpha1-1);
        h2[k] = alpha2*lambda2*k^(alpha2-1);
        pk = (h1[k]+h2[k])/((alpha1*lambda1/(alpha1+1)*((t)^(alpha1+1) - 2^(alpha1+1))) + (alpha2*lambda2/(alpha2+1)*((t)^(alpha2+1) - 2^(alpha2+1)))); // h(k) / H(t) (integrated from 2 to t)
        expected_riskset[j,t,k] = expected_riskset[j, t-1, k-1] - pk*(expected_deaths[t-1,j] +  expected_riskset[j, t-1, k-1]* (h1[k-1]+ h2[k-1])) +0.0001;
        expected_deaths[k,j] += expected_riskset[j,t,k] * h1[k]  +0.0001;
        expected_recovereds[k,j] += expected_riskset[j,t,k] * (h2[k]) * (dr)^w[j]+0.0001;
        
      }
  
      
    }
  }
}


model {
  //definitely can be made more effcient.
  for (j in 1:L) {
    for (t in 1:T) {
      target+=poisson_lpmf(d[t,j]|expected_deaths[t,j]) + poisson_lpmf(r[t,j]|expected_recovereds[t,j]);
    }
  }
 
}

```


Prep data and run model. 

```{r message=FALSE, warning=FALSE, include=FALSE}
library(readr)
library(tidyverse)
   #Load in the JHU CSSE Data
  date <- ISOdate(2020,2,4)
   jhucsse <- read_JHUCSSE_cases("2020-02-05 1:33", 
                                 append_wiki = TRUE)
  
  ##Continue to filter to China for the moment.
  ##also total the suspected and confirmed cases.
  jhucsse_china <- jhucsse %>% 
    filter(Country_Region%in%c("Mainland China", "Macau", "Hong Kong")) 
  
  jhucsse_china$Province_State <- as.factor(jhucsse_china$Province_State)

  
  incidence_data <- est_daily_incidence(jhucsse_china,
                                        ISOdate(2019,12,1),
                                        date)
  
   #look at this before we do it.
  inc_plt <- incidence_data%>%filter(Date>"2020-1-1") %>% 
    ggplot(aes(x=Date,  y=Incidence, fill=Province_State)) +
    geom_bar(stat="identity", position="stack") +
    theme_bw()+theme(legend.position="bottom")
  

  inc_plt


  incidence_data<-
    incidence_data%>%filter(Date>"2020-1-1")
  
  #Add columns with indices for time and location
  incidence_data$loc <-
    as.numeric(incidence_data$Province_State)
  incidence_data$t <- as.numeric(as.Date(incidence_data$Date))-
    min(as.numeric(as.Date(incidence_data$Date))) + 1
  
  
 
  confirmed_data <- incidence_data
  confirmed_data$confirmeds <-ave(confirmed_data$Incidence, confirmed_data$loc, FUN=cumsum)
  
  Tmax <- max(incidence_data$t)
  L <- max(incidence_data$loc)
  cases <- matrix(0,nrow=Tmax, ncol=L)
  
  for (i in 1:nrow(incidence_data)) {
    cases[incidence_data$t[i], incidence_data$loc[i]] <-
      incidence_data$Incidence[i]
  }
  
  confirmeds <- matrix(0,nrow=Tmax, ncol=L)
    for (i in 1:nrow(confirmed_data)) {
    confirmeds[confirmed_data$t[i], confirmed_data$loc[i]] <-
        confirmed_data$confirmeds[i]
  }

  recov_data <- est_daily_recovered(jhucsse_china,
                                    ISOdate(2019,12,1),
                                   date,
                                    na_to_zeros = TRUE)

   recov_plt <- recov_data%>%filter(Date>"2020-1-1") %>% 
    ggplot(aes(x=Date,   y=Recovered, fill=Province_State)) +
    geom_bar(stat="identity", position="stack") +
    theme_bw()+theme(legend.position="bottom")
  

  recov_plt
  
   recov_data<-
    recov_data%>%filter(Date>"2020-1-1")
  
  #Add columns with indices for time and location
  recov_data$loc <-
    as.numeric(recov_data$Province_State)
  recov_data$t <- as.numeric(as.Date(recov_data$Date))-
    min(as.numeric(as.Date(recov_data$Date))) + 1

  
 
  #recov_data$totrecovered <-ave(recov_data$Recovered, recov_data$loc, FUN=cumsum)
  
  recovered <- matrix(0,nrow=Tmax, ncol=L)
    for (i in 1:nrow(recov_data)) {
    recovered[recov_data$t[i], recov_data$loc[i]] <-

        recov_data$Recovered[i]
  }
  
  
  
   death_data <- est_daily_deaths(jhucsse_china,
                                  ISOdate(2019,12,1),
                                  date)
   
  #look at this before we do it.
  death_plt <- death_data%>%filter(Date>"2020-1-1") %>% 
    ggplot(aes(x=Date,   y=Deaths, fill=Province_State)) +
    geom_bar(stat="identity", position="stack") +
    theme_bw()+theme(legend.position="bottom")
  

  death_plt


  death_data<-
    death_data%>%filter(Date>"2020-1-1") %>% 
    drop_na(Deaths)
  
  
  #Add columns with indices for time and location
  death_data$loc <-
    as.numeric(as.numeric(death_data$Province_State))
  death_data$t <- as.numeric(as.Date(death_data$Date))-
    min(as.numeric(as.Date(incidence_data$Date))) + 1
  
  
  deaths <- matrix(0,nrow=Tmax, ncol=L)
  
  for (i in 1:nrow(death_data)) {
    deaths[death_data$t[i], death_data$loc[i]] <-
      death_data$Deaths[i]
  }
 
  deaths<- round(deaths)
  #deaths[deaths<0] <- 0

  totdeaths <-apply(deaths, 2, cumsum)
  totrecov <-apply(recovered, 2, cumsum)
  infected <- confirmeds - (totdeaths + totrecov)
 
  cumexit <- totdeaths + totrecov
  infected[infected<0] <- 0
  recovered[recovered<0] <- 0
   exit = round(deaths + recovered)
  confirmeds[confirmeds == 0] <- 0.0001
  #recovered[recovered == 0] <- 0.0001
  infected[infected == 0] <- 0.001
  cases[cases == 0] <- 0.0001
 
    ##we now have everything to run our stan model 
  cfrmdl_je_data1 <- list(T=Tmax, L=L,
                      c = confirmeds,
                      d = round(totdeaths),
                      r = totrecov,
                      e = cumexit,
                      n = round(infected),
                      V = 100)



  ##we now have everything to run our stan model 2
  cfrmdl_je_data2 <- list(T=Tmax, L=L,
                      c = cases,
                      d = round(deaths),
                      r = round(recovered),
                      e = exit,
                      n = infected,
                      V = 100)
Tmax
  
#work on nonconstant hazards
  
# Estimate detection rate for recoveries in hubei
 #  detectrate <- matrix(1, nrow = nrow(infected), ncol = ncol(infected))
 # 
 # obscfr <-  totrecov[nrow(totrecov),]/(totdeaths[nrow(totrecov),] + totrecov[nrow(totrecov),])
 # detectrate[, 14] <- obscfr[14]/mean(obscfr[-14], na.rm = TRUE)
 # 

### estimating function for CFR
# ef <- function(h, deaths, recovered, n, detectrate){
#   expected_deaths = n * h[1]
#   expected_obs_recov = (n * h[2]) * (detectrate)
#   ee1 <- (deaths - expected_deaths)^2
#   ee2 <- (recovered - expected_obs_recov)^2
#   ee <- sum(ee1)+sum(ee2)
#   return(sum(ee))
# }
# 
# 
# fit<-optim(c(rep(.5, 2)), fn=ef, deaths= deaths, recovered = recovered, n = infected, detectrate = detectrate, control=c(maxit=100000))
# bhat<-fit$par
# 
# h <- bhat[2] + bhat[1]
# rho <- integrate(function(x) {bhat[1]*exp(-h*x)}, 
#                         lower = 0, upper = Inf)$value
# 
# rho
  
w <- vector(length = ncol(infected))
w[unlist(head(incidence_data[incidence_data$Province_State == "Hubei",  "loc"], n=1))] <- 1
c
  ##we now have everything to run our stan model 2 (results should match estimating function above)
  cfrmdl_je_data2 <- list(T=Tmax, L=L,
                      c = cases,
                      d = round(deaths),
                      r = round(recovered),
                      w = w)
    cfrmdl_je_data3<- list(T=Tmax, L=L,
                      c = cases,
                      d = round(deaths),
                      r = round(recovered),
                      w = w, 
                      V = nrow(cases))
```


```{r, eval = FALSE}
  cfrmdl_je_res <- sampling(cfrmdl3, data=cfrmdl_je_data3,
                         iter=200)
  chains <- extract(cfrmdl_je_res)
  lambda1 <- chains$lambda1
  #lambda2 <- chains$lambda2
  lambda <- chains$lambda
  # alpha1 <- chains$alpha1
  #alpha2 <- chains$alpha2
  dr <- chains$dr
  mean(dr)
  #outdat <- data.frame(lambda1 = lambda1, lambda2 = lambda, alpha1 = alpha1, alpha2 = alpha2 , dr = dr)
  outdat <- data.frame(lambda1 = lambda1, lambda = lambda, dr = dr)
  save(outdat, file = "data/outdat.RData")

```

Summarize


```{r, echo = FALSE }
load("data/outdat.RData")

lambda1 <- outdat[,1] #chains$lambda1
lambda <- outdat[,2] #chains$lambda

  
plot(density(lambda1), xlim=c(0,.1), type = "l")
lines(density(lambda))
plot(lambda, type = "l")
plot(lambda1, type = "l")



```

Results
```{r}

#move this into stan model later
rho <- matrix(nrow = length(lambda1))
for(i in 1:length(lambda1)){

  try (
    rho[i] <- integrate(function(x) {lambda1[i]*exp(-lambda[i]*x)}, 
                        lower = 0, upper = Inf)$value)
}
rho <- rho[!is.na(rho)]
median(rho)
quantile(rho, probs = c(.025, .975))
#mean(lambda)
plot(density(rho))
plot(log(rho), type = "l")
#max(rho)


```

Parking lot for time varying hazard stuff

```{r}

# estimate distribution of infection duration on each day
  # outputs a list of Tx33 matrices (one row per calendar day; 1 column per max possible infection duration)
# this isn't great because only adds people, doesn't remove them from riskset at death/recovery!
# onsets <- list()
#  cases2 <- data.frame(cases = cases, day = c(1:nrow(cases)))
#   for(i in 1:ncol(cases)){
#      onsets[[i]] <-  cases2[,c(i, ncol(cases2))]
#      onsets[[i]] <- as.data.frame(lapply(onsets[[i]], rep, onsets[[i]][,1]))
#   }
#             
# probs <- list()
# for(k in 1:length(onsets))  {
#   om <- matrix(ncol = 33, nrow = nrow(onsets[[k]]))
#   probs[[k]] <- matrix(ncol = nrow(cases), nrow = 33) #nrow = max inf dur
#   for(i in 1:ncol(om)){
#     om[,i] <- ifelse(i - onsets[[k]]$day>=0, (i - onsets[[k]]$day)+1, NA)
#     t <- table(om[,i])
#     if(length(t)>0) pt <- as.data.frame(prop.table(t)) #ifelse(length(t)>0, prop.table(t), cbind(rep(0, 3), rep(0, 3),rep(0, 3)))
#     if(length(t) == 0) pt <- as.data.frame(cbind(0, 0))
#       names(pt) <- c("InfDur", "p")
#     probs[[k]][,i] <- c(pt$p, rep(0, nrow(probs[[k]])-nrow(pt)))
#   }
# }
# 
# 
# # read in individual level data
# 
# MKdata_times <- read_MK_linelist("2-3-2020")

    ##we now have everything to run our stan model 2
  cfrmdl_je_data3<- list(T=Tmax, L=L,
                      c = confirmeds,
                      d = round(deaths),
                      r = round(recovered),
                      e = round(exit),
                      n = infected,
                      p = probs)
```