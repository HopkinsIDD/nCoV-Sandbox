---
title: "Simple CFR approach"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

 
require(knitr)
require(tidyverse)
require(gridExtra)
require(rstan)
require(splines2)
require(readr)


source("../R/DataLoadUtils.r")
source("../R/BasicEpiAnalyses.r")
source("../R/CFRutils.r")

```



First, define the stan model.

```{stan, eval = FALSE, output.var="cfrmdl2"}

data {
  int <lower=0> T; //the number of time steps included
  int <lower=0> L; //the number of locations we have data from
  int <lower=0> r[T,L]; //  number of recovered cases reported on each day.
  int <lower=0> d[T,L]; //  number of deaths reported on each day. 
  real <lower=0> c[T,L]; //number of new cases  on each day. 
  int w[L]; //is this wuhan
}

parameters {
  real <lower=0> lambda1; //parameter for time to death distribution
  real <lower=0> lambda; // parameter for time to death or recovery distribution
  real <lower= 0, upper=1> dr; // wuhan detect rate
}

transformed parameters {
  real <lower=0> expected_deaths[T,L]; //  # deaths at time T
  real <lower=0> expected_recovereds[T,L]; //  # those who have exited due to recovery at T
  real <lower=0> expected_riskset[T,L]; // expected people in risk set

for (j in 1:L) {
    expected_riskset[1,j] = c[1,j];
    expected_deaths[1,j] = expected_riskset[1,j] * lambda1 + 0.0001 ;
    expected_recovereds[1,j] = expected_riskset[1,j] * (lambda - lambda1) * (dr)^w[j] + 0.0001;
 
    for (t in 2:T) {
      expected_riskset[t,j] =  expected_riskset[t-1,j] + c[t,j] - 
                                expected_deaths[t-1,j] - expected_riskset[t-1,j] * (lambda - lambda1);
      expected_deaths[t,j] = expected_riskset[t,j] * lambda1 + 0.0001 ;
      expected_recovereds[t,j] = expected_riskset[t,j] * (lambda - lambda1) * (dr)^w[j] + 0.0001;
      
    }
  }
}


model {
  //definitely can be made more effcient.
  for (j in 1:L) {
    for (t in 1:T) {
      target+=poisson_lpmf(d[t,j]|expected_deaths[t,j]) + poisson_lpmf(r[t,j]|expected_recovereds[t,j]);
    }
  }
 
}


```

Now, attempt to allow hazards to vary over time.
```{stan, eval = FALSE, output.var="cfrmdl3b"}

data {
  int <lower=0> T; //the number of time steps included
  int <lower=0> L; //the number of locations we have data from
  int <lower = 0> V; // max infection duration (may not be needed)
  int <lower=0> r[T,L]; //  number of recovered cases reported on each day.
  int <lower=0> d[T,L]; //  number of deaths reported on each day. 
  real <lower=0> c[T,L]; //number of new cases  on each day. 
  int w[L]; //is this wuhan
}

parameters {
  //real <lower=0> lambda1; //parameter for time to death distribution
  //real <lower=0> lambda2; // parameter for time to death or recovery distribution
  //real <lower=0> alpha1; //parameter for time to death distribution
  //real <lower=0> alpha2; // parameter for time to death or recovery distribution
  real <lower= 0, upper=1> dr; // wuhan detect rate
  real  <lower=0> lambda1;
  real <lower=0> lambda2 ;
  real  <lower=0> alpha1;
  real <lower=0> alpha2 ;
}

transformed parameters {
  real <lower=0> expected_deaths[T,L]; //  # deaths at time T
  real <lower=0> expected_recovereds[T,L]; //  # those who have exited due to recovery at T
  matrix[V,T] expected_riskset[L]; // expected people in risk set in inf dur timescale
  real  <lower=0> h1[V];
  real <lower=0> h2[V];


for (j in 1:L) {
    expected_riskset[j][1,1] = c[1,j]+0.0001; //risk set on day 1 at inf duration 1 is just c1
    expected_deaths[1,j] = expected_riskset[j][1,1] * alpha1*lambda1^alpha1 + 0.0001 ;
    expected_recovereds[1,j] = expected_riskset[j][1,1] * alpha2*lambda2^alpha2 * (dr)^w[j] + 0.0001;
 

    for (t in 2:T) {
      expected_riskset[j][1,t] = c[t,j]+0.0001;
      expected_deaths[t,j] = expected_riskset[j][1,t] * alpha1*lambda1^alpha1 + 0.0001 ;
      expected_recovereds[t,j] = expected_riskset[j][1,t] * alpha2*lambda2^alpha2 * (dr)^w[j] + 0.0001;
      h1[1] = alpha1*lambda1^alpha1;
      h2[1] = alpha2*lambda2^alpha2;
      
      for(k in 2:t){
       h1[k] = alpha1*lambda1^alpha1*k^(alpha1-1);
       h2[k] = alpha2*lambda2^alpha2*k^(alpha2-1);
        expected_riskset[j][k,t] = expected_riskset[j][k-1,t-1] - (expected_riskset[j][k-1,t-1]*h1[k-1] +  (expected_riskset[j][k-1,t-1]* h2[k-1]))+0.0001;
        expected_deaths[k,j] +=  expected_riskset[j][k,t] * h1[k] ;
        expected_recovereds[k,j] +=  expected_riskset[j][k,t] * h2[k] * (dr)^w[j];

      }
    }
  }
}


model {
  //definitely can be made more effcient.
  for (j in 1:L) {
    for (t in 1:T) {
      target+=poisson_lpmf(d[t,j]|expected_deaths[t,j]) + poisson_lpmf(r[t,j]|expected_recovereds[t,j]);
    }
  }
 
}

```


Prep data 

```{r message=FALSE, warning=FALSE, include=FALSE}
library(readr)
library(tidyverse)
   #Load in the JHU CSSE Data
  todaydate <- ISOdate(2020,2,10, hour = 23, min = 59, tz = "EST")
  

mod2_nohubei <- moddata(todaydate, withHubei = FALSE)
mod2 <- moddata(todaydate, withHubei = TRUE)
```


```{r, eval = FALSE}
  cfrmdl_je_res <- sampling(cfrmdl3b, data=mod2,
                         iter=100)
  chains <- extract(cfrmdl_je_res)
  lambda1 <- chains$lambda1
  #lambda2 <- chains$lambda2
  lambda <- chains$lambda
  # alpha1 <- chains$alpha1
  #alpha2 <- chains$alpha2
  dr <- chains$dr
  mean(dr)
  #outdat <- data.frame(lambda1 = lambda1, lambda2 = lambda, alpha1 = alpha1, alpha2 = alpha2 , dr = dr)
  outdat <- data.frame(lambda1 = lambda1, lambda = lambda, dr = dr)
  save(outdat, file = "../data/outdat.RData")

```

Summarize


```{r, echo = FALSE }
load("../data/outdat.RData")

lambda1 <- outdat[,1] #chains$lambda1
lambda <- outdat[,2] #chains$lambda
#alpha1 <- outdat[,3]
#alpha2 <- outdat[,4]
dr <- outdat[,3]
  
# plot(density(lambda1), xlim=c(0,.1), type = "l")
# lines(density(lambda))
# plot(lambda, type = "l")
# plot(lambda1, type = "l")



```

Results
```{r}

#move this into stan model later
rho <- matrix(nrow = length(lambda1))
for(i in 1:length(lambda1)){

  try (
    rho[i] <- integrate(function(x) {lambda1[i]*exp(-lambda[i]*x)}, 
                        lower = 0, upper = Inf)$value)
}
rho <- rho[!is.na(rho)]
median(rho)
quantile(rho, probs = c(.025, .975))
#mean(lambda)
plot(density(rho))
plot(log(rho), type = "l")
#max(rho)


```

